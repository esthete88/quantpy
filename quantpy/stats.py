import numpy as np
from tqdm.notebook import tqdm

from .tomography.state import StateTomograph
from .tomography.process import ProcessTomograph


def get_CL_list_state(state, n_iter=1000, n_boot=1000, n_measurements=1000, method='lin', method_boot='lin',
                      dst='hs', POVM='proj-set', physical=True, init='lin', tol=1e-3, max_iter=100,
                      mhmc=False, step=0.01, burn_steps=1000, thinning=1, verbose=True, POVM_noise=0):
    """Conducts `n_iter` experiments, constructs confidence intervals for each,
    computes confidence level that corresponds to the distance between
    the target state and the point estimate and returns a sorted list of these levels.

    Parameters
    ----------
    state : Qobj
        Quantum object to perform a tomography on.
    n_iter : int
        Number of experiments to perform.
    n_boot : int
        Number of samples from the distribution to obtain.
    n_measurements : int or array-like
        Number of measurements to perform in the tomography.
    mhmc : boolean
        If True, uses Metropolis-Hastings Monte Carlo instead of bootstrapping to sample from the distribution.
    method : str
        Method of reconstructing the density matrix

        Possible values:
            'lin' -- linear inversion
            'mle' -- maximum likelihood estimation with Cholesky parameterization, unconstrained optimization
            'mle-constr' -- same as 'mle', but optimization is constrained
            'mle-bloch' -- maximum likelihood estimation with Bloch parametrization,
                           constrained optimization (works only for 1-qubit systems)

    method_boot : str
        Method of reconstructing the bootstrapped samples. See method() documentation for the details.
    dst : str or callable
        Measure in a space of quantum objects

        Possible strings:
            'hs' -- Hilbert-Schmidt distance
            'trace' -- trace distance
            'if' -- infidelity

        Interface for a custom measure:
            custom_measure(A: Qobj, B: Qobj) -> float

    POVM : str or numpy 2-D array
        A single string or a numpy array to construct a POVM matrix.

        Possible strings:
            'proj' -- random orthogonal projective measurement, 6^n_qubits rows
            'proj-set' -- true orthogonal projective measurement, set of POVMs
            'sic' -- SIC POVM for 1-qubit systems and its tensor products for higher dimensions, 4^n_qubits rows

        Possible numpy arrays:
            2-D array with shape (*, 4) -- interpreted as POVM matrix for 1 qubit,
            construct a POVM matrix for the whole system from tensor products of rows of this matrix
            3-D array with shape (*, *, 4) -- same, but set of POVMs
            2-D array with shape (*, 4^n_qubits) -- returns this matrix without any changes
            3-D array with shape (*, *, 4^n_qubits) -- same, but set of POVMs

        See :ref:`generate_measurement_matrix` for more detailed documentation

    physical : bool (optional)
        For methods 'lin' and 'mle' reconstructed matrix may not lie in the physical domain.
        If True, set negative eigenvalues to zeros and divide the matrix by its trace.

    init : str (optional)
        Methods using maximum likelihood estimation require the starting point for gradient descent.

        Possible values:
            'lin' -- uses linear inversion point estimate as initial guess.
            'mixed' -- uses fully mixed state as initial guess.

    max_iter : int (optional)
        Number of iterations in MLE method.
    tol : float (optional)
        Error tolerance in MLE method.
    step : float
        Multiplier used in each step.
    burn_steps : int
        Steps for burning in.
    thinning : int
        Takes each `thinning` sample generated by MCMC.
    verbose : boolean
        If True, shows progress.
    POVM_noise : float, default=0
        Add noise to each POVM: with probability `POVM_noise` the outcome of each measurement is noisy.

    Returns
    -------
    Numpy array
        Sorted list of confidence levels.
    """
    results = np.empty(n_iter)

    tmg = StateTomograph(state, dst)
    cycle = tqdm(range(n_iter)) if verbose else range(n_iter)

    for i in cycle:
        tmg.experiment(n_measurements, POVM, POVM_noise=POVM_noise)

        state_hat = tmg.point_estimate(method, physical, init, max_iter, tol)
        delta = tmg.dst(state, state_hat)
        if mhmc:
            distances, _ = tmg.mhmc(n_boot, step, burn_steps, thinning)
        else:
            distances = tmg.bootstrap(n_boot, method_boot, physical, init, tol, max_iter)
        indices_falling_into_CL = np.where(delta > distances)[0]
        if len(indices_falling_into_CL) == 0:
            results[i] = 0
        else:
            results[i] = indices_falling_into_CL[-1] / n_boot

    results = np.sort(results)
    return results


def get_CL_list_channel(channel, n_iter=1000, n_boot=1000, n_measurements=1000, method='lifp', method_boot='lifp',
                        dst='hs', POVM='proj-set', input_states='proj4', cptp=True, tol=1e-3, states_physical=True,
                        states_init='lin', states_est_method='lin', states_est_method_boot='lin', input_impurity=0.05,
                        max_iter=100, mhmc=False, step=0.01, burn_steps=1000, thinning=1, verbose=True, POVM_noise=0):
    """Conducts `n_iter` experiments, constructs confidence intervals for each,
    computes confidence level that corresponds to the distance between
    the target Choi matrix and the point estimate and returns a sorted list of these levels.

    Parameters
    ----------
    channel : Channel
        Quantum channel to perform a tomography on.
    n_iter : int
        Number of experiments to perform.
    n_boot : int
        Number of samples from the distribution to obtain.
    n_measurements : int or array-like
        Number of measurements to perform in the tomography.
    mhmc : boolean
        If True, uses Metropolis-Hastings Monte Carlo instead of bootstrapping to sample from the distribution.
    method : str, default='lifp'
        Method of reconstructing the Choi matrix

        Possible values:
            'lifp' -- linear inversion
            'pgdb' -- projected gradient descent (CPTP only)
            'states' -- reconstruction of the Choi matrix using a basis of reconstructed quantum states

    method_boot : str
        Method of reconstructing the bootstrapped samples. See method() documentation for the details.
    dst : str or callable
        Measure in a space of quantum objects

        Possible strings:
            'hs' -- Hilbert-Schmidt distance
            'trace' -- trace distance
            'if' -- infidelity

        Interface for a custom measure:
            custom_measure(A: Qobj, B: Qobj) -> float

    POVM : str or numpy 2-D array
        A single string or a numpy array to construct a POVM matrix.

        Possible strings:
            'proj' -- random orthogonal projective measurement, 6^n_qubits rows
            'proj-set' -- true orthogonal projective measurement, set of POVMs
            'sic' -- SIC POVM for 1-qubit systems and its tensor products for higher dimensions, 4^n_qubits rows

        Possible numpy arrays:
            2-D array with shape (*, 4) -- interpreted as POVM matrix for 1 qubit,
            construct a POVM matrix for the whole system from tensor products of rows of this matrix
            3-D array with shape (*, *, 4) -- same, but set of POVMs
            2-D array with shape (*, 4^n_qubits) -- returns this matrix without any changes
            3-D array with shape (*, *, 4^n_qubits) -- same, but set of POVMs

        See :ref:`generate_measurement_matrix` for more detailed documentation

    input_states : str or list
        Set of quantum states to be used in the process tomography
    cptp : bool, default=True
        If True, return a projection onto CPTP space.
    states_physical : bool (optional)
       For 'states' method defines if the point estimates of the quantum states should be physical
    states_init : str (optional)
       For 'states' method with MLE sets an initial point for gradient descent

       Possible values:
           'lin' -- uses linear inversion point estimate as initial guess
           'mixed' -- uses fully mixed state as initial guess

    states_est_method : str
        Method of reconstructing the density matrix

        Possible values:
            'lin' -- linear inversion
            'mle' -- maximum likelihood estimation with Cholesky parameterization, unconstrained optimization
            'mle-constr' -- same as 'mle', but optimization is constrained
            'mle-bloch' -- maximum likelihood estimation with Bloch parametrization,
                           constrained optimization (works only for 1-qubit systems)

    states_est_method_boot : str
        Method of reconstructing the bootstrapped samples. See method() documentation for the details.
    input_impurity : float
        Depolarize each input state using depolarizing channel with p = `input_impurity`
        in order to avoid biased point estimate.
    max_iter : int (optional)
        Number of iterations in MLE method.
    tol : float (optional)
        Error tolerance in MLE method.
    step : float
        Multiplier used in each step.
    burn_steps : int
        Steps for burning in.
    thinning : int
        Takes each `thinning` sample generated by MCMC.
    verbose : boolean
        If True, shows progress.
    POVM_noise : float, default=0
        Add noise to each POVM: with probability `POVM_noise` the outcome of each measurement is noisy.

    Returns
    -------
    Numpy array
        Sorted list of confidence levels.
    """
    results = np.empty(n_iter)

    tmg = ProcessTomograph(channel, input_states, dst, input_impurity)
    cycle = tqdm(range(n_iter)) if verbose else range(n_iter)

    for i in cycle:
        tmg.experiment(n_measurements, POVM, POVM_noise=POVM_noise)

        channel_hat = tmg.point_estimate(method, states_est_method=states_est_method,
                                         states_physical=states_physical, states_init=states_init)
        delta = tmg.dst(channel.choi, channel_hat.choi)
        if mhmc:
            distances, _ = tmg.mhmc(n_boot, step, burn_steps, thinning, states_physical=states_physical,
                                    states_est_method=states_est_method_boot, states_init=states_init)
        else:
            distances = tmg.bootstrap(n_boot, method_boot, cptp, n_iter, tol, states_physical=states_physical,
                                      states_est_method=states_est_method_boot, states_init=states_init)
        indices_falling_into_CL = np.where(delta > distances)[0]
        if len(indices_falling_into_CL) == 0:
            results[i] = 0
        else:
            results[i] = indices_falling_into_CL[-1] / n_boot

    results = np.sort(results)
    return results
